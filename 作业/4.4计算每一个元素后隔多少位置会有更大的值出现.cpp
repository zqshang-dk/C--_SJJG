/*---------------题目描述开始---------------
题目：
有一个长度为n的整数数组，数组元在[0,100]区间内随机取值。
请计算每一个元素后隔多少位置会有更大的值出现，如果后面没有更大的值，结果为0。
要求时间复杂度为O(n)，可以考虑用栈解决。
比如，数组为[35, 36, 39, 30, 28, 16, 66, 33]，答案为[1, 1, 4, 3, 2, 1, 0, 0]
本题可以使用STL中的stack容器类
输入格式：
数据1
数据1 数据2 ... 数据n 
输出格式
数据1 数据2 ... 数据n  

---------------题目描述结束---------------
*/
//在下方写出程序应该包含的头文件
#include<iostream>
#include<stack>
using namespace std;

int main() {
    int n;
	cin >> n;
	int* a = new int[n];         //数组a中输入长度为n的整数数组
	for (int i = 0; i < n; ++i)
		cin >> a[i];
	int* b = new int[n];         //数组b中保存结果

    //--------------在本行下方编程程序代码，不要修改main()函数中本行及以上的内容----------------------
	//个人感觉这个题最重要的是这个思路
	//首先，很考察这个栈是一个什么作用，为什么要用栈？――其实是用来存放下标而不是元素值的
	//因为最后要求的是，隔多少个元素会有更大的值
	//所以我们要求的，其实是元素索引值之差，而不是元素大小的差值，所以这里要采用的是stack存放元素索引！
	stack<int> st;

	for (int i = n-1; i >=0;i--){
		while(!st.empty() && a[st.top()]<=a[i]){
			st.pop();
		}
		if(st.empty()){
			b[i] = 0;
		}
		else{
			b[i] = st.top() - i;
		}
		st.push(i);
	}

	//--------------代码编辑结束，不要修改本行及以下的内容----------------------

	for (int i = 0; i < n; ++i)
	{
		cout << b[i] << " ";
	}
	delete [] a;
	delete [] b;
    
    return 0;
}




